unit uWhereClauseBuilder;

interface

uses System.SysUtils, System.StrUtils;

type
  TClause = (tcFrom = 1, tcWhere, tcGroupBy, tcHaving, tcOrderBy);

const
  WHERE_CLAUSE = 'WHERE';
  ORDERBY_CLAUSE = 'ORDER BY';
  HAVING_CLAUSE = 'HAVING';
  GROUPBY_CLAUSE = 'GROUP BY';
  FROM_CLAUSE = 'FROM';
  LOGIC_OPERATOR_AND = 'AND';

  TClauseStrings: array [TClause] of string =
    (FROM_CLAUSE, WHERE_CLAUSE, GROUPBY_CLAUSE, HAVING_CLAUSE, ORDERBY_CLAUSE);

type
  TWhereClauseBuilder = class
  private
    FSQL: string;
    FSQLOriginal: string;
    function GetClause(AClause: TClause): string;
    function GetEndPositionClause(AClause: TClause): Integer;
    function GetWhereClause: string;
  public
    constructor Create(SQL: String);
    procedure AddWhere(Where: String);
    function GetAliasFromClause: string;
  published
    property SQL: string read FSQL;
    property SQLOriginal: string read FSQLOriginal;
    property Where: string read GetWhereClause;
  end;

implementation

{ TWhereClause }

procedure TWhereClauseBuilder.AddWhere(Where: String);
var AliasFrom, WhereClause: string;
  PosInsert: Integer;
begin
  if (AnsiContainsText(AnsiUpperCase(FSQL), AnsiUpperCase(WHERE_CLAUSE))) then
  begin
    WhereClause := GetWhereClause();
    PosInsert := Pos(WhereClause, FSQL) + Length(WhereClause);

    if (PosInsert >= Length(FSQL)) then
    begin
      FSQL := Trim(FSQL) + ' ';
      Inc(PosInsert);
    end;

    Insert(Format('%s ', [Where]),
      FSQL, PosInsert + 1);
  end
  else
  begin
    if (AnsiContainsText(AnsiUpperCase(Where), AnsiUpperCase(LOGIC_OPERATOR_AND))) then
    if (Pos(LOGIC_OPERATOR_AND, Where) > 0) then
      Where := Trim(StringReplace(Where, LOGIC_OPERATOR_AND, '', []));

    AliasFrom := GetAliasFromClause();
    PosInsert := Pos(AliasFrom, FSQL) + Length(AliasFrom);

    FSQL := Trim(FSQL) + ' ';

    Insert(Format('%s %s ', [WHERE_CLAUSE, Where]),
      FSQL, PosInsert + 1);
  end;

  FSQL := Trim(FSQL);
end;

constructor TWhereClauseBuilder.Create(SQL: String);
begin
  FSQL := SQL;
  FSQLOriginal := SQL;
end;

function TWhereClauseBuilder.GetAliasFromClause: string;
var
  PosFrom, PosEnd: Integer;
  FromClause: string;
begin
  PosFrom := Pos(FROM_CLAUSE, FSQL);

  if (PosFrom > 0) then
  begin
    PosFrom := PosFrom + 4;

    if (Pos(WHERE_CLAUSE, FSQL) > 0) then
      PosEnd := Pos(WHERE_CLAUSE, FSQL) - PosFrom
    else if (Pos(GROUPBY_CLAUSE, FSQL) > 0) then
      PosEnd := Pos(GROUPBY_CLAUSE, FSQL) - PosFrom
    else if (Pos(ORDERBY_CLAUSE, FSQL) > 0) then
      PosEnd := Pos(ORDERBY_CLAUSE, FSQL) - PosFrom
    else
      PosEnd := Length(FSQL) - PosFrom + 1;

    FromClause := Trim(Copy(FSQL, PosFrom, PosEnd));
    if (Pos(' ', FromClause) > 0) then
      Result := Trim(Copy(FromClause,
                          Pos(' ', FromClause),
                          Length(FromClause) - Pos(' ', FromClause) + 1))
    else
      Result := FromClause;
  end
  else
    Result := '';
end;

function TWhereClauseBuilder.GetWhereClause: string;
begin
  Result := GetClause(tcWhere);
end;

function TWhereClauseBuilder.GetClause(AClause: TClause): string;
var
  PosClause, PosClauseEnd: Integer;
begin
  PosClause := Pos(TClauseStrings[AClause], FSQL);

  if (PosClause > 0) then
  begin
    PosClauseEnd := GetEndPositionClause(AClause);

    Result := Trim(Copy(FSQL, PosClause, PosClauseEnd - PosClause));
  end
  else
    Result := EmptyStr;
end;

function TWhereClauseBuilder.GetEndPositionClause(AClause: TClause): Integer;
var
  NextClause, ForClause: TClause;
begin
  if (AClause = High(TClause)) then
    NextClause := AClause
  else
  begin
    NextClause := AClause;
    for ForClause := TClause(Ord(AClause) + 1) to High(TClause) do
      if (AnsiContainsText(AnsiUpperCase(FSQL), AnsiUpperCase(TCLauseStrings[ForClause]))) then
      Begin
        NextClause := ForClause;
        Break;
      End;
  end;

  if (NextClause = AClause) then
    Result := Length(FSQL) + 1
  else
    Result := Pos(TCLauseStrings[NextClause], FSQL);
end;

end.
